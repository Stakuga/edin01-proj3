from scipy.spatial.distance import hamming
import itertools
import matplotlib.pyplot as plt

# Implement the three polynomials as shift registers

# For each polynomial, generate a sequence of length N for a number of different initial states
# And for each sequence generated by the initial state, calculate the hamming distance

keystreamText = "0000111100111100001001010111001000000100111110101000011011100010101110010110011000011100111011000001101110011111010111111010101100100110111110111010100100001110011010110111010010101011001001000"
keystream = []
for letter in keystreamText:
    keystream.append(int(letter))

# Register L1:

# Produce a keystream sequence for passed initial state:
def L1(state, streamLength):
    a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 = state[0], state[1], state[2], state[3], state[4], state[5], state[6], state[7], state[8], state[9], state[10], state[11], state[12] 
    sequence = [a1]
    for i in range(1, streamLength):
        newDigit = (a1 + a2 + a4 + a6 + a7 + a10 + a11 + a13) % 2
        a13 = a12
        a12 = a11
        a11 = a10
        a10 = a9
        a9 = a8
        a8 = a7
        a7 = a6
        a6 = a5
        a5 = a4
        a4 = a3
        a3 = a2
        a2 = a1
        a1 = newDigit
        sequence.append(a1)
    return(sequence)

def findInitialL1():
    largestDistance = 0
    bestPValue = 0
    bestInitialState = (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)

    initialStates = list(itertools.product([0, 1], repeat=13))
    initialStates = initialStates[1:]

    pvalues = []
    xvalues = list(range(len(initialStates)))

    for i in initialStates:
        sequence = L1(i, 193)
        ham = hamming(keystream, sequence)
        p = 1 - ham
        pvalues.append(p)
        if abs(p - 0.5) > largestDistance:
            largestDistance = abs(p - 0.5)
            bestPValue = p
            bestInitialState = i

    plt.scatter(xvalues, pvalues)
    plt.title("Initial States generating p* values for LFSR 1")
    plt.xlabel("Initial States")
    plt.ylabel("p* Values")
    plt.xticks(color='w')
    plt.show()

    return(bestInitialState, bestPValue)

# Register L2:

# Produce a keystream sequence for passed initial state:
def L2(state, streamLength):
    a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15 = state[0], state[1], state[2], state[3], state[4], state[5], state[6], state[7], state[8], state[9], state[10], state[11], state[12], state[13], state[14] 
    sequence = [a1]
    for i in range(1, streamLength):
        newDigit = (a2 + a4 + a6 + a7 + a10 + a11 + a13 + a15) % 2
        a15 = a14
        a14 = a13
        a13 = a12
        a12 = a11
        a11 = a10
        a10 = a9
        a9 = a8
        a8 = a7
        a7 = a6
        a6 = a5
        a5 = a4
        a4 = a3
        a3 = a2
        a2 = a1
        a1 = newDigit
        sequence.append(a1)
    return(sequence)

def findInitialL2():
    largestDistance = 0
    bestPValue = 0
    bestInitialState = (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)

    initialStates = list(itertools.product([0, 1], repeat=15))
    initialStates = initialStates[1:]

    pvalues = []
    xvalues = list(range(len(initialStates)))

    for i in initialStates:
        sequence = L2(i, 193)
        ham = hamming(keystream, sequence)
        p = 1 - ham
        pvalues.append(p)
        if abs(p - 0.5) > largestDistance:
            largestDistance = abs(p - 0.5)
            bestPValue = p
            bestInitialState = i
    
    plt.scatter(xvalues, pvalues)
    plt.title("Initial States generating p* values for LFSR 2")
    plt.xlabel("Initial States")
    plt.ylabel("p* Values")
    plt.xticks(color='w')
    plt.show()

    return(bestInitialState, bestPValue)

# Register L3:

# Produce a keystream sequence for passed initial state:
def L3(state, streamLength):
    a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17 = state[0], state[1], state[2], state[3], state[4], state[5], state[6], state[7], state[8], state[9], state[10], state[11], state[12], state[13], state[14], state[15], state[16]
    sequence = [a1]
    for i in range(1, streamLength):
        newDigit = (a2 + a4 + a5 + a8 + a10 + a13 + a16 + a17) % 2
        a17 = a16
        a16 = a15
        a15 = a14
        a14 = a13
        a13 = a12
        a12 = a11
        a11 = a10
        a10 = a9
        a9 = a8
        a8 = a7
        a7 = a6
        a6 = a5
        a5 = a4
        a4 = a3
        a3 = a2
        a2 = a1
        a1 = newDigit
        sequence.append(a1)
    return(sequence)

def findInitialL3():
    largestDistance = 0
    bestInitialState = (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
    bestPValue = 0

    initialStates = list(itertools.product([0, 1], repeat=17))
    initialStates = initialStates[1:]

    pvalues = []
    xvalues = list(range(len(initialStates)))

    for i in initialStates:
        sequence = L3(i, 193)
        ham = hamming(keystream, sequence)
        p = 1 - ham
        pvalues.append(p)
        if abs(p - 0.5) > largestDistance:
            largestDistance = abs(p - 0.5)
            bestPValue = p
            bestInitialState = i
    
        
    plt.scatter(xvalues, pvalues)
    plt.title("Initial States generating p* values for LFSR 3")
    plt.xlabel("Initial States")
    plt.ylabel("p* Values")
    plt.xticks(color='w')
    plt.show()

    return(bestInitialState, bestPValue)

# Determine initial states and p values for each shift register
# with greatest deviation between p* and 0.5

output1 = findInitialL1()
output2 = findInitialL2()
output3 = findInitialL3()

# Assign initial states for each shift register
# with greatest deviation between p* and 0.5

l1 = output1[0]
l2 = output2[0]
l3 = output3[0]

# Produce streams for each shift register based 
# on calculated initial states

l1stream = L1(l1, 193)
l2stream = L2(l2, 193)
l3stream = L3(l3, 193)

# Combine streams from shift registers together 
# to generate a keystream

stream = ""

for i in range(len(l1stream)):
    value = l1stream[i] + l2stream[i] + l3stream[i]
    if value > 1:
        stream = stream + "1"
    else:
        stream = stream + "0"

# Check if generated keystream equals actual keystream
    
if keystreamText == stream:
    print("Correct keystream successfully generated.")
    print("Initial state for L1 is ", l1)
    print("Corresponding best probability p for L1 is ", output1[1])
    print("Initial state for L2 is ", l2)
    print("Corresponding best probability p for L2 is ", output2[1])
    print("Initial state for L3 is ", l3)
    print("Corresponding best probability p for L3 is ", output3[1])
else:
    print("Incorrect keystream generated.")