from scipy.spatial.distance import hamming
import itertools

# Implement the three polynomials as shift registers

# For each polynomial, generate a sequence of length N for a number of different initial states
# And for each sequence generated by the initial state, calculate the hamming distance

keystreamText = "0000111100111100001001010111001000000100111110101000011011100010101110010110011000011100111011000001101110011111010111111010101100100110111110111010100100001110011010110111010010101011001001000"
keystream = []
for letter in keystreamText:
    keystream.append(int(letter))

# Register L1:

# Produce a keystream sequence for passed initial state:
def L1(state, streamLength):
    a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 = state[0], state[1], state[2], state[3], state[4], state[5], state[6], state[7], state[8], state[9], state[10], state[11], state[12] 
    sequence = [a1]
    for i in range(1, streamLength):
        newDigit = (a1 + a2 + a4 + a6 + a7 + a10 + a11 + a13) % 2
        a13 = a12
        a12 = a11
        a11 = a10
        a10 = a9
        a9 = a8
        a8 = a7
        a7 = a6
        a6 = a5
        a5 = a4
        a4 = a3
        a3 = a2
        a2 = a1
        a1 = newDigit
        sequence.append(a1)
    return(sequence)

def findInitialL1():
    largestDistance = 0
    bestInitialState = (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)

    initialStates = list(itertools.product([0, 1], repeat=13))
    initialStates = initialStates[1:]

    for i in initialStates:
        sequence = L1(i, 193)
        ham = hamming(keystream, sequence)
        p = 1 - ham
        if abs(p - 0.5) > largestDistance:
            largestDistance = abs(p - 0.5)
            bestInitialState = i

    print(largestDistance)
    return(bestInitialState)

#p = findInitialL1()
#print(p)


# Register L2:

# Produce a keystream sequence for passed initial state:
def L2(state, streamLength):
    a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15 = state[0], state[1], state[2], state[3], state[4], state[5], state[6], state[7], state[8], state[9], state[10], state[11], state[12], state[13], state[14] 
    sequence = [a1]
    for i in range(1, streamLength):
        newDigit = (a2 + a4 + a6 + a7 + a10 + a11 + a13 + a15) % 2
        a15 = a14
        a14 = a13
        a13 = a12
        a12 = a11
        a11 = a10
        a10 = a9
        a9 = a8
        a8 = a7
        a7 = a6
        a6 = a5
        a5 = a4
        a4 = a3
        a3 = a2
        a2 = a1
        a1 = newDigit
        sequence.append(a1)
    return(sequence)

def findInitialL2():
    largestDistance = 0
    bestInitialState = (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)

    initialStates = list(itertools.product([0, 1], repeat=15))
    initialStates = initialStates[1:]

    for i in initialStates:
        sequence = L2(i, 193)
        ham = hamming(keystream, sequence)
        p = 1 - ham
        if abs(p - 0.5) > largestDistance:
            largestDistance = abs(p - 0.5)
            bestInitialState = i

    print(largestDistance)
    return(bestInitialState)

#l2 = findInitialL2()
#print(l2)

# Register L3:

# Produce a keystream sequence for passed initial state:
def L3(state, streamLength):
    a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17 = state[0], state[1], state[2], state[3], state[4], state[5], state[6], state[7], state[8], state[9], state[10], state[11], state[12], state[13], state[14], state[15], state[16]
    sequence = [a1]
    for i in range(1, streamLength):
        newDigit = (a2 + a4 + a5 + a8 + a10 + a13 + a16 + a17) % 2
        a17 = a16
        a16 = a15
        a15 = a14
        a14 = a13
        a13 = a12
        a12 = a11
        a11 = a10
        a10 = a9
        a9 = a8
        a8 = a7
        a7 = a6
        a6 = a5
        a5 = a4
        a4 = a3
        a3 = a2
        a2 = a1
        a1 = newDigit
        sequence.append(a1)
    return(sequence)

def findInitialL3():
    largestDistance = 0
    bestInitialState = (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)

    initialStates = list(itertools.product([0, 1], repeat=17))
    initialStates = initialStates[1:]

    for i in initialStates:
        sequence = L3(i, 193)
        ham = hamming(keystream, sequence)
        p = 1 - ham
        if abs(p - 0.5) > largestDistance:
            largestDistance = abs(p - 0.5)
            bestInitialState = i

    print(largestDistance)
    return(bestInitialState)

l1 = findInitialL1()
l2 = findInitialL2()
l3 = findInitialL3()

l1stream = L1(l1, 193)
l2stream = L2(l2, 193)
l3stream = L3(l3, 193)

stream = ""

for i in range(len(l1stream)):
    value = l1stream[i] + l2stream[i] + l3stream[i]
    if value > 1:
        stream = stream + "1"
    else:
        stream = stream + "0"
    
if keystreamText == stream:
    print("hooray")


# Exercise 2

# 2^13 - 1 combinations for first key.
# 2^15 - 1 combinations for second key.
# 2^17 - 1 combinations for third key.

# In the above correlation attack we produce all the initial states once, and then compare them
# in time linear to that of the length of the stream. The dominant time comes from producing 
# all of the initial states once. 

# To check the entire keyspace, we'd have to generate every initial state and then compare them
# with each other. Assuming each attack takes T seconds, we'd have 8191 * 32767 * 131071 * T
# which equals 35178735116287T attacks to do in the worst case. 